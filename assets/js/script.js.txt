document.addEventListener("DOMContentLoaded", () => {
  // Búsqueda en tiempo real
  const searchInput = document.getElementById("search-input")
  if (searchInput) {
    searchInput.addEventListener("input", () => {
      filterItems()
    })
  }

  // Cambio de tema
  const themeToggle = document.getElementById("theme-toggle")
  if (themeToggle) {
    themeToggle.addEventListener("click", () => {
      // Usar la función global de cambio de tema
      window.toggleTheme()
    })

    // Ya no necesitamos cargar el tema guardado aquí, se hace en theme-handler.php
  }

  // Botón de actualizar
  const refreshBtn = document.getElementById("refresh-btn")
  if (refreshBtn) {
    refreshBtn.addEventListener("click", () => {
      // Añadir animación antes de recargar
      const icon = refreshBtn.querySelector("i")
      icon.classList.add("fa-spin")

      // Recargar después de un breve retraso para ver la animación
      setTimeout(() => {
        location.reload()
      }, 300)
    })
  }

  // Cambio de vista (tarjeta/lista)
  const viewToggle = document.getElementById("view-toggle")
  if (viewToggle) {
    viewToggle.addEventListener("click", function () {
      const container = document.querySelector("main .container")
      container.classList.toggle("list-view")

      // Cambiar el icono
      const icon = this.querySelector("i")
      if (container.classList.contains("list-view")) {
        icon.classList.remove("fa-list")
        icon.classList.add("fa-th-large")
      } else {
        icon.classList.remove("fa-th-large")
        icon.classList.add("fa-list")
      }

      // Guardar preferencia en localStorage
      const view = container.classList.contains("list-view") ? "list" : "card"
      localStorage.setItem("view", view)
    })

    // Cargar vista guardada
    const savedView = localStorage.getItem("view")
    if (savedView === "list") {
      const container = document.querySelector("main .container")
      container.classList.add("list-view")
      const icon = viewToggle.querySelector("i")
      icon.classList.remove("fa-list")
      icon.classList.add("fa-th-large")
    } else {
      // Asegurarse de que la vista de tarjeta sea la predeterminada
      const container = document.querySelector("main .container")
      container.classList.remove("list-view")
      const icon = viewToggle.querySelector("i")
      icon.classList.remove("fa-th-large")
      icon.classList.add("fa-list")
    }
  }

  // Corregir el comportamiento del botón volver en el visor
  const volverBtn = document.querySelector('.nav-button[href="javascript:history.back()"]')
  if (volverBtn) {
    volverBtn.addEventListener("click", (e) => {
      e.preventDefault()
      history.back()
    })
  }

  // Variables para almacenar los filtros activos
  let activeSort = "name-asc" // Ordenación predeterminada: A-Z
  let activeTypeFilter = "all" // Filtro de tipo predeterminado: todos

  // Filtro y ordenación - NUEVA IMPLEMENTACIÓN CON BOTONES SEPARADOS
  const filterBtn = document.getElementById("filter-btn")
  const filterDropdown = document.getElementById("filter-dropdown")
  const sortBtn = document.getElementById("sort-btn")
  const sortDropdown = document.getElementById("sort-dropdown")

  // Crear overlay para el fondo en móvil (compartido entre ambos dropdowns)
  const filterOverlay = document.createElement("div")
  filterOverlay.className = "filter-overlay"
  document.body.appendChild(filterOverlay)

  // Función para crear botón de cierre para modales
  function createCloseButton(dropdown) {
    const closeBtn = document.createElement("button")
    closeBtn.className = "filter-close-btn"
    closeBtn.innerHTML = '<i class="fas fa-times"></i>'
    closeBtn.setAttribute("aria-label", "Cerrar")

    // Asegurarse de que el botón se inserte al principio del dropdown
    if (dropdown.firstChild) {
      dropdown.insertBefore(closeBtn, dropdown.firstChild)
    } else {
      dropdown.appendChild(closeBtn)
    }

    return closeBtn
  }

  // Configurar el dropdown de filtro
  if (filterBtn && filterDropdown) {
    const closeBtn = createCloseButton(filterDropdown)

    // Función para mostrar el filtro - Modificada para corregir el scroll
    const showFilter = () => {
      // Ocultar el otro dropdown si está abierto
      if (sortDropdown && sortDropdown.classList.contains("show")) {
        sortDropdown.classList.remove("show")
        sortBtn.classList.remove("active")
      }

      // Posicionar correctamente el dropdown en escritorio
      if (window.innerWidth > 768) {
        const btnRect = filterBtn.getBoundingClientRect()
        filterDropdown.style.top = `${btnRect.bottom + window.scrollY}px`
        filterDropdown.style.right = `${window.innerWidth - btnRect.right}px`

        // Asegurar que el dropdown no cause scroll
        const viewportHeight = window.innerHeight
        const dropdownHeight = filterDropdown.offsetHeight
        const dropdownBottom = btnRect.bottom + dropdownHeight

        if (dropdownBottom > viewportHeight) {
          // Si el dropdown se sale de la pantalla, ajustar su posición
          filterDropdown.style.top = `${btnRect.top - dropdownHeight + window.scrollY}px`
        }
      }

      filterDropdown.classList.add("show")
      filterOverlay.classList.add("show")
      filterBtn.classList.add("active")

      // Marcar las opciones activas
      updateActiveFilterOptions()
    }

    // Función para ocultar el filtro
    const hideFilter = () => {
      filterDropdown.classList.remove("show")
      filterOverlay.classList.remove("show")
      filterBtn.classList.remove("active")
    }

    // Evento para mostrar el filtro
    filterBtn.addEventListener("click", (e) => {
      e.stopPropagation() // Evitar que el clic se propague al documento
      if (filterDropdown.classList.contains("show")) {
        hideFilter()
      } else {
        showFilter()
      }
    })

    // Evento para cerrar con el botón de cierre
    closeBtn.addEventListener("click", hideFilter)

    // Manejar clics en las opciones de filtro
    const filterOptions = filterDropdown.querySelectorAll(".filter-option")
    filterOptions.forEach((option) => {
      option.addEventListener("click", () => {
        const filterType = option.getAttribute("data-filter")
        const filterValue = option.getAttribute("data-value")

        if (filterType === "type") {
          activeTypeFilter = filterValue

          // Actualizar el estado visual del botón
          if (filterValue === "all") {
            filterBtn.classList.remove("active")
          } else {
            filterBtn.classList.add("active")
          }
        }

        // Aplicar filtros
        filterItems()

        // Actualizar opciones activas
        updateActiveFilterOptions()

        // Cerrar el menú después de seleccionar
        setTimeout(() => {
          hideFilter()
        }, 200)
      })
    })
  }

  // Configurar el dropdown de ordenación
  if (sortBtn && sortDropdown) {
    const closeBtn = createCloseButton(sortDropdown)

    // Función para mostrar el ordenador - Modificada para corregir el scroll
    const showSort = () => {
      // Ocultar el otro dropdown si está abierto
      if (filterDropdown && filterDropdown.classList.contains("show")) {
        filterDropdown.classList.remove("show")
        filterBtn.classList.remove("active")
      }

      // Posicionar correctamente el dropdown en escritorio
      if (window.innerWidth > 768) {
        const btnRect = sortBtn.getBoundingClientRect()
        sortDropdown.style.top = `${btnRect.bottom + window.scrollY}px`
        sortDropdown.style.right = `${window.innerWidth - btnRect.right}px`

        // Asegurar que el dropdown no cause scroll
        const viewportHeight = window.innerHeight
        const dropdownHeight = sortDropdown.offsetHeight
        const dropdownBottom = btnRect.bottom + dropdownHeight

        if (dropdownBottom > viewportHeight) {
          // Si el dropdown se sale de la pantalla, ajustar su posición
          sortDropdown.style.top = `${btnRect.top - dropdownHeight + window.scrollY}px`
        }
      }

      sortDropdown.classList.add("show")
      filterOverlay.classList.add("show")
      sortBtn.classList.add("active")

      // Marcar las opciones activas
      updateActiveFilterOptions()
    }

    // Función para ocultar el ordenador
    const hideSort = () => {
      sortDropdown.classList.remove("show")
      filterOverlay.classList.remove("show")
      sortBtn.classList.remove("active")
    }

    // Evento para mostrar el ordenador
    sortBtn.addEventListener("click", (e) => {
      e.stopPropagation() // Evitar que el clic se propague al documento
      if (sortDropdown.classList.contains("show")) {
        hideSort()
      } else {
        showSort()
      }
    })

    // Evento para cerrar con el botón de cierre
    closeBtn.addEventListener("click", hideSort)

    // Manejar clics en las opciones de ordenación
    const sortOptions = sortDropdown.querySelectorAll(".filter-option")
    sortOptions.forEach((option) => {
      option.addEventListener("click", () => {
        const filterType = option.getAttribute("data-filter")
        const filterValue = option.getAttribute("data-value")

        if (filterType === "sort") {
          activeSort = filterValue

          // Actualizar el icono del botón según la ordenación
          const sortIcon = sortBtn.querySelector("i")
          if (filterValue.includes("asc")) {
            sortIcon.className = "fas fa-sort-amount-down"
          } else {
            sortIcon.className = "fas fa-sort-amount-up"
          }

          // Siempre mantener el botón de ordenar como activo
          sortBtn.classList.add("active")
        }

        // Aplicar filtros
        filterItems()

        // Actualizar opciones activas
        updateActiveFilterOptions()

        // Cerrar el menú después de seleccionar
        setTimeout(() => {
          hideSort()
        }, 200)
      })
    })
  }

  // Evento para cerrar con el overlay
  filterOverlay.addEventListener("click", () => {
    // Ocultar ambos dropdowns
    if (filterDropdown) filterDropdown.classList.remove("show")
    if (sortDropdown) sortDropdown.classList.remove("show")
    filterOverlay.classList.remove("show")
    if (filterBtn) filterBtn.classList.remove("active")
    if (sortBtn) sortBtn.classList.remove("active")
  })

  // Cerrar los menús al hacer clic fuera de ellos (para escritorio)
  document.addEventListener("click", (e) => {
    if (
      !e.target.closest(".filter-button") &&
      !e.target.closest(".filter-dropdown") &&
      !e.target.closest(".sort-button") &&
      !e.target.closest(".sort-dropdown")
    ) {
      if (filterDropdown) filterDropdown.classList.remove("show")
      if (sortDropdown) sortDropdown.classList.remove("show")
      filterOverlay.classList.remove("show")
      if (filterBtn) filterBtn.classList.remove("active")
      if (sortBtn) sortBtn.classList.remove("active")
    }
  })

  // Ajustar posición de los dropdowns al cambiar el tamaño de la ventana
  window.addEventListener("resize", () => {
    // Solo reposicionar si están abiertos y estamos en escritorio
    if (window.innerWidth > 768) {
      if (filterDropdown && filterDropdown.classList.contains("show") && filterBtn) {
        const btnRect = filterBtn.getBoundingClientRect()
        filterDropdown.style.top = `${btnRect.bottom + window.scrollY}px`
        filterDropdown.style.right = `${window.innerWidth - btnRect.right}px`
      }

      if (sortDropdown && sortDropdown.classList.contains("show") && sortBtn) {
        const btnRect = sortBtn.getBoundingClientRect()
        sortDropdown.style.top = `${btnRect.bottom + window.scrollY}px`
        sortDropdown.style.right = `${window.innerWidth - btnRect.right}px`
      }
    }
  })

  // Función para marcar las opciones de filtro activas
  function updateActiveFilterOptions() {
    // Actualizar opciones de filtro
    const filterOptions = document.querySelectorAll(".filter-option")
    filterOptions.forEach((option) => {
      const filterType = option.getAttribute("data-filter")
      const filterValue = option.getAttribute("data-value")

      // Quitar la clase activa de todas las opciones
      option.classList.remove("active")

      // Añadir la clase activa a las opciones seleccionadas
      if (
        (filterType === "sort" && filterValue === activeSort) ||
        (filterType === "type" && filterValue === activeTypeFilter)
      ) {
        option.classList.add("active")
      }
    })
  }

  // Función para filtrar y ordenar elementos
  function filterItems() {
    const searchTerm = searchInput ? searchInput.value.toLowerCase() : ""
    const unifiedList = document.getElementById("unified-list")

    if (unifiedList) {
      const items = Array.from(unifiedList.querySelectorAll(".folder-item, .file-item"))
      let visibleItems = 0

      // Filtrar por término de búsqueda y tipo
      items.forEach((item) => {
        const itemName = item.querySelector(".folder-name, .file-name").textContent.toLowerCase()
        const itemType = item.getAttribute("data-type") || ""
        const itemExtension = item.getAttribute("data-extension") || ""

        // Verificar si el elemento coincide con el término de búsqueda
        const matchesSearch = itemName.includes(searchTerm)

        // Verificar si el elemento coincide con el filtro de tipo
        let matchesTypeFilter = true
        if (activeTypeFilter !== "all") {
          if (activeTypeFilter === "folder") {
            // Filtrar solo carpetas
            matchesTypeFilter = itemType === "folder"
          } else if (activeTypeFilter === "file") {
            // Filtrar solo archivos
            matchesTypeFilter = itemType === "file"
          } else {
            // Filtrar por extensión específica
            matchesTypeFilter = itemExtension === activeTypeFilter
          }
        }

        // Mostrar u ocultar el elemento según los filtros
        if (matchesSearch && matchesTypeFilter) {
          item.style.display = ""
          visibleItems++
        } else {
          item.style.display = "none"
        }
      })

      // Ordenar elementos visibles
      sortItems(items, activeSort)

      // Mostrar mensaje si no hay resultados
      const noResultsUnified = document.getElementById("no-results-unified")
      if (noResultsUnified) {
        if (visibleItems === 0 && (searchTerm !== "" || activeTypeFilter !== "all")) {
          noResultsUnified.classList.add("visible")
        } else {
          noResultsUnified.classList.remove("visible")
        }
      }
    }
  }

  // Función para ordenar elementos
  function sortItems(items, sortOrder) {
    // Filtrar solo los elementos visibles
    const visibleItems = items.filter((item) => item.style.display !== "none")

    // Ordenar según el criterio seleccionado
    visibleItems.sort((a, b) => {
      const nameA = a.getAttribute("data-name").toLowerCase()
      const nameB = b.getAttribute("data-name").toLowerCase()

      // Obtener fechas para ordenación por fecha
      let dateA, dateB
      if (a.classList.contains("file-item") && a.querySelector(".file-date")) {
        dateA = a.querySelector(".file-date").textContent
      } else {
        // Para carpetas en la página principal, intentar obtener la fecha de modificación
        const folderCount = a.querySelector(".folder-count")
        if (folderCount) {
          // Intentar extraer la fecha de los atributos de datos
          dateA = a.getAttribute("data-modified") || "01/01/2000 00:00"
        } else {
          dateA = "01/01/2000 00:00" // Fecha por defecto para carpetas
        }
      }

      if (b.classList.contains("file-item") && b.querySelector(".file-date")) {
        dateB = b.querySelector(".file-date").textContent
      } else {
        // Para carpetas en la página principal, intentar obtener la fecha de modificación
        const folderCount = b.querySelector(".folder-count")
        if (folderCount) {
          // Intentar extraer la fecha de los atributos de datos
          dateB = b.getAttribute("data-modified") || "01/01/2000 00:00"
        } else {
          dateB = "01/01/2000 00:00" // Fecha por defecto para carpetas
        }
      }

      // Convertir fechas a objetos Date para comparación
      const dateParts1 = dateA.split(" ")[0].split("/")
      const timeParts1 = dateA.split(" ")[1] ? dateA.split(" ")[1].split(":") : ["00", "00"]
      const dateObj1 = new Date(
        Number.parseInt(dateParts1[2]),
        Number.parseInt(dateParts1[1]) - 1,
        Number.parseInt(dateParts1[0]),
        Number.parseInt(timeParts1[0]),
        Number.parseInt(timeParts1[1]),
      )

      const dateParts2 = dateB.split(" ")[0].split("/")
      const timeParts2 = dateB.split(" ")[1] ? dateB.split(" ")[1].split(":") : ["00", "00"]
      const dateObj2 = new Date(
        Number.parseInt(dateParts2[2]),
        Number.parseInt(dateParts2[1]) - 1,
        Number.parseInt(dateParts2[0]),
        Number.parseInt(timeParts2[0]),
        Number.parseInt(timeParts2[1]),
      )

      if (sortOrder === "name-asc") {
        return nameA.localeCompare(nameB)
      } else if (sortOrder === "name-desc") {
        return nameB.localeCompare(nameA)
      } else if (sortOrder === "date-desc") {
        return dateObj2 - dateObj1 // Más reciente primero
      } else if (sortOrder === "date-asc") {
        return dateObj1 - dateObj2 // Más antiguo primero
      }

      return 0
    })

    // Reordenar los elementos en el DOM
    const parent = items[0].parentNode
    visibleItems.forEach((item) => {
      parent.appendChild(item)
    })
  }

  // Inicializar filtros al cargar
  updateActiveFilterOptions()

  // Añadir función para corregir el scroll al cargar la página
  function fixInitialScroll() {
    // Forzar un reflow para corregir el scroll inicial
    document.body.style.overflow = "hidden"
    setTimeout(() => {
      document.body.style.overflow = ""
    }, 10)
  }

  // Ejecutar la función para corregir el scroll al cargar la página
  fixInitialScroll()
})
